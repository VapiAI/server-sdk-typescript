// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { normalizeClientOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import type * as Vapi from "../../../index.js";

export declare namespace CallsClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class CallsClient {
    protected readonly _options: CallsClient.Options;

    constructor(options: CallsClient.Options) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * @param {Vapi.ListCallsRequest} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.list()
     */
    public list(
        request: Vapi.ListCallsRequest = {},
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.Call[]> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: Vapi.ListCallsRequest = {},
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.Call[]>> {
        const {
            id,
            assistantId,
            phoneNumberId,
            limit,
            createdAtGt,
            createdAtLt,
            createdAtGe,
            createdAtLe,
            updatedAtGt,
            updatedAtLt,
            updatedAtGe,
            updatedAtLe,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (id != null) {
            _queryParams.id = id;
        }

        if (assistantId != null) {
            _queryParams.assistantId = assistantId;
        }

        if (phoneNumberId != null) {
            _queryParams.phoneNumberId = phoneNumberId;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (createdAtGt != null) {
            _queryParams.createdAtGt = createdAtGt;
        }

        if (createdAtLt != null) {
            _queryParams.createdAtLt = createdAtLt;
        }

        if (createdAtGe != null) {
            _queryParams.createdAtGe = createdAtGe;
        }

        if (createdAtLe != null) {
            _queryParams.createdAtLe = createdAtLe;
        }

        if (updatedAtGt != null) {
            _queryParams.updatedAtGt = updatedAtGt;
        }

        if (updatedAtLt != null) {
            _queryParams.updatedAtLt = updatedAtLt;
        }

        if (updatedAtGe != null) {
            _queryParams.updatedAtGe = updatedAtGe;
        }

        if (updatedAtLe != null) {
            _queryParams.updatedAtLe = updatedAtLe;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                "call",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.Call[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling GET /call.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Vapi.CreateCallDto} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.create()
     */
    public create(
        request: Vapi.CreateCallDto = {},
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.CreateCallsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Vapi.CreateCallDto = {},
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.CreateCallsResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                "call",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.CreateCallsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling POST /call.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Vapi.CallControllerFindAllPaginatedRequest} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.callControllerFindAllPaginated({
     *         assistantIdAny: "assistant-1,assistant-2,assistant-3",
     *         customerNumberAny: "+1234567890,+0987654321"
     *     })
     */
    public callControllerFindAllPaginated(
        request: Vapi.CallControllerFindAllPaginatedRequest = {},
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.CallPaginatedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__callControllerFindAllPaginated(request, requestOptions));
    }

    private async __callControllerFindAllPaginated(
        request: Vapi.CallControllerFindAllPaginatedRequest = {},
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.CallPaginatedResponse>> {
        const {
            assistantIdAny,
            assistantOverrides,
            customer,
            customerNumberAny,
            assistantId,
            assistantName,
            squadId,
            squadName,
            id,
            idAny,
            costLe,
            costGe,
            cost,
            successEvaluation,
            endedReason,
            phoneNumberId,
            phoneNumberIdAny,
            structuredOutputs,
            score,
            page,
            sortOrder,
            limit,
            createdAtGt,
            createdAtLt,
            createdAtGe,
            createdAtLe,
            updatedAtGt,
            updatedAtLt,
            updatedAtGe,
            updatedAtLe,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (assistantIdAny != null) {
            _queryParams.assistantIdAny = assistantIdAny;
        }

        if (assistantOverrides != null) {
            _queryParams.assistantOverrides = toJson(assistantOverrides);
        }

        if (customer != null) {
            _queryParams.customer = toJson(customer);
        }

        if (customerNumberAny != null) {
            _queryParams.customerNumberAny = customerNumberAny;
        }

        if (assistantId != null) {
            _queryParams.assistantId = assistantId;
        }

        if (assistantName != null) {
            _queryParams.assistantName = assistantName;
        }

        if (squadId != null) {
            _queryParams.squadId = squadId;
        }

        if (squadName != null) {
            _queryParams.squadName = squadName;
        }

        if (id != null) {
            _queryParams.id = id;
        }

        if (idAny != null) {
            if (Array.isArray(idAny)) {
                _queryParams.idAny = idAny.map((item) => item);
            } else {
                _queryParams.idAny = idAny;
            }
        }

        if (costLe != null) {
            _queryParams.costLe = costLe.toString();
        }

        if (costGe != null) {
            _queryParams.costGe = costGe.toString();
        }

        if (cost != null) {
            _queryParams.cost = cost.toString();
        }

        if (successEvaluation != null) {
            _queryParams.successEvaluation = successEvaluation;
        }

        if (endedReason != null) {
            _queryParams.endedReason = endedReason;
        }

        if (phoneNumberId != null) {
            _queryParams.phoneNumberId = phoneNumberId;
        }

        if (phoneNumberIdAny != null) {
            if (Array.isArray(phoneNumberIdAny)) {
                _queryParams.phoneNumberIdAny = phoneNumberIdAny.map((item) => item);
            } else {
                _queryParams.phoneNumberIdAny = phoneNumberIdAny;
            }
        }

        if (structuredOutputs != null) {
            _queryParams.structuredOutputs = toJson(structuredOutputs);
        }

        if (score != null) {
            _queryParams.score = score;
        }

        if (page != null) {
            _queryParams.page = page.toString();
        }

        if (sortOrder != null) {
            _queryParams.sortOrder = sortOrder;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (createdAtGt != null) {
            _queryParams.createdAtGt = createdAtGt;
        }

        if (createdAtLt != null) {
            _queryParams.createdAtLt = createdAtLt;
        }

        if (createdAtGe != null) {
            _queryParams.createdAtGe = createdAtGe;
        }

        if (createdAtLe != null) {
            _queryParams.createdAtLe = createdAtLe;
        }

        if (updatedAtGt != null) {
            _queryParams.updatedAtGt = updatedAtGt;
        }

        if (updatedAtLt != null) {
            _queryParams.updatedAtLt = updatedAtLt;
        }

        if (updatedAtGe != null) {
            _queryParams.updatedAtGe = updatedAtGe;
        }

        if (updatedAtLe != null) {
            _queryParams.updatedAtLe = updatedAtLe;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                "v2/call",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.CallPaginatedResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling GET /v2/call.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Vapi.GetCallsRequest} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.get({
     *         id: "id"
     *     })
     */
    public get(
        request: Vapi.GetCallsRequest,
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.Call> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Vapi.GetCallsRequest,
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.Call>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                `call/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.Call, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling GET /call/{id}.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Vapi.DeleteCallDto} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.delete({
     *         id: "id"
     *     })
     */
    public delete(
        request: Vapi.DeleteCallDto,
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.Call> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Vapi.DeleteCallDto,
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.Call>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                `call/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.Call, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling DELETE /call/{id}.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Vapi.UpdateCallDto} request
     * @param {CallsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.calls.update({
     *         id: "id"
     *     })
     */
    public update(
        request: Vapi.UpdateCallDto,
        requestOptions?: CallsClient.RequestOptions,
    ): core.HttpResponsePromise<Vapi.Call> {
        return core.HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
    }

    private async __update(
        request: Vapi.UpdateCallDto,
        requestOptions?: CallsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Vapi.Call>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.VapiEnvironment.Default,
                `call/${core.url.encodePathParam(id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Vapi.Call, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.VapiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.VapiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.VapiTimeoutError("Timeout exceeded when calling PATCH /call/{id}.");
            case "unknown":
                throw new errors.VapiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
